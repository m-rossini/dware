/*
 * Copyright (c) 2004-2005 Auster Solutions do Brasil. All Rights Reserved.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Created on Apr 8, 2005
 */
package br.com.auster.dware.filter;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.nio.channels.Channels;
import java.nio.channels.WritableByteChannel;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.w3c.dom.Element;

import br.com.auster.common.io.IOUtils;
import br.com.auster.common.io.NIOUtils;
import br.com.auster.common.util.I18n;
import br.com.auster.common.xml.DOMUtils;
import br.com.auster.dware.graph.ConnectException;
import br.com.auster.dware.graph.DefaultFilter;
import br.com.auster.dware.graph.FilterException;
import br.com.auster.dware.graph.Request;
import br.com.auster.dware.request.file.FileRequest;

/**
 * This filter is used to write the result of a processed request to a file.
 * Each request will be written to a different file.
 * 
 * @version $Id: OutputToFile.java 225 2006-08-10 23:19:41Z rbarone $
 */
public class OutputToFile extends DefaultFilter {

   public static final String GZIP_ATTR = "use-gzip";

   public static final String PREFIX_ATTR = "prefix";

   public static final String SUFFIX_ATTR = "suffix";

   public static final String APPEND_ATTR = "append";

   public static final String TMP_ATTR = "use-tmp-file";

   public static final String FORMAT_ATT = "format";

   public static final String FILENAME_ELEMENT = "filename";

   public static final String GENERATED_FILES_KEY = "generatedFiles";

   protected FilenameBuilder filenameBuilder;
   
   protected String formatName;

   protected String namePrefix, nameSuffix;

   protected File file;

   protected Request request;

   protected boolean append, useTmp;

   protected WritableByteChannel writer;

   protected static final Logger log = Logger.getLogger(OutputToFile.class);

   private final I18n i18n = I18n.getInstance(OutputToFile.class);

   private boolean isFormatActive = false;

   public OutputToFile(String name) {
      super(name);
   }

   /**
    * Configures this filter.
    */
   public synchronized void configure(Element config) throws FilterException {
      // Gets the prefix and suffix for the output file name
      namePrefix = config.getAttribute(PREFIX_ATTR);
      nameSuffix = config.getAttribute(SUFFIX_ATTR);

      // The user may specify to use gzip by the properties or by the file name
      // suffix.
      if (DOMUtils.getBooleanAttribute(config, GZIP_ATTR) && !nameSuffix.endsWith(".gz"))
         nameSuffix += ".gz";

      // Decides if the user wants to append or to overide the output file.
      this.append = DOMUtils.getBooleanAttribute(config, APPEND_ATTR);

      // Decides if the user wants to write to a tmp file before
      // moving to the definitive file.
      this.useTmp = DOMUtils.getBooleanAttribute(config, TMP_ATTR);

      // In theory, a file is generated when we want to persist some kind
      // of processing result, usually some formatted output in a specific
      // layout (even if it's a binary file). With the formatName variable,
      // the user can name the format being generated by this filter and,
      // through configuration, decide if he wants to create the format 
      // or not.
      this.formatName = DOMUtils.getAttribute(config, FORMAT_ATT, false);
      
      // Initializes a new FilenameBuilder to handle the output filename creation.
      Element filenameElt = DOMUtils.getElement(config, FILENAME_ELEMENT, false);
      this.filenameBuilder = new FilenameBuilder(filenameElt);
   }

   /**
    * Opens the file for writing the output processed for the request.
    * 
    * @param request
    *           the request to be processed.
    */
   public void prepare(Request request) throws FilterException {
      this.request = request;

      this.isFormatActive = false;
      if (this.formatName != null && this.formatName.length() > 0) {
         List atts = (List) request.getAttributes().get(FORMAT_ATT);
         if (atts != null && !atts.contains(this.formatName)) {
            this.writer = Channels.newChannel(new ByteArrayOutputStream());
            return;
         }
         this.isFormatActive = true;
         Map generatedFiles;
         if (request.getAttributes().containsKey(GENERATED_FILES_KEY)) {
            generatedFiles = (Map) request.getAttributes().get(GENERATED_FILES_KEY);
         } else {
            generatedFiles = new HashMap();
            request.getAttributes().put(GENERATED_FILES_KEY, generatedFiles);
         }
         generatedFiles.put(this.formatName, null);
      }

      try {
         if (useTmp) {
            this.file = File.createTempFile(Integer.toString(request.hashCode()), "tmp");
         } else {
            this.file = this.getFile(request);
         }

         if (this.isFormatActive) {
            Map generatedFiles = (Map) this.request.getAttributes().get(GENERATED_FILES_KEY);
            generatedFiles.put(this.formatName, this.file.getAbsolutePath());
         }
         
         log.info(i18n.getString("setOutputRequest", request, this.file));
         
         this.writer = NIOUtils.openFileForWrite(this.file, this.append);
      } catch (IOException e) {
         throw new FilterException(i18n.getString("problemCreatingFile", request), e);
      }
   }

   /**
    * Creates the file that will be opened for writing as the output.
    * 
    * @param request
    *           the file name will be defined using some request's properties.
    */
   protected synchronized File getFile(Request request) throws FilterException {
      String fileName = this.filenameBuilder.getFilename(request);
      if (fileName == null || fileName.length() == 0) {
        //Belows "&" operation is to guarantee that the file name will not start with minus signal.
        fileName = String.valueOf(request.hashCode() & 0x7FFFFFFF);
      }
      if (request instanceof FileRequest) {
         File input = ((FileRequest) request).getFile();
         if (this.namePrefix.length() == 0) {
            // If a prefix is not defined, put the output in the same directory
            // as
            // the input.
            File parentFile = input.getParentFile();
            if (parentFile == null) {
               parentFile = new File("./");
            }
            return new File(parentFile.getAbsolutePath() + fileName + this.nameSuffix);
         }
      }
      File outputFile = new File(this.namePrefix + fileName + this.nameSuffix);
      try {
        IOUtils.createParentDirs(outputFile);
      } catch (IOException e) {
        throw new FilterException(i18n.getString("problemCreatingFile", request), e);
      }
      return outputFile;
   }

   /**
    * Closes the output.
    */
   public void commit() {

    try {
      if (this.writer != null && this.writer.isOpen()) {
        this.writer.close();
      }
    } catch (IOException e) {
      log.error(i18n.getString("problemClosingFile"), e);
    }

    if (this.file != null) {
      if (this.useTmp) {
        try {
          File newFile = this.getFile(request);
          if (!this.file.renameTo(newFile)) {
            throw new RuntimeException(i18n.getString("couldNotMoveFile", this.file, newFile));
          }
        } catch (FilterException e) {
          throw new RuntimeException(e);
        }
      }
    }

    this.file = null;
    this.request = null;
  }

   /**
     * Closes the output.
     */
   public void rollback() {
	  if (this.isFormatActive) {
		 // unset filename (to null) so that others know 
		 // that we had to rollback
	 	 Map generatedFiles = (Map) 
	 	 	this.request.getAttributes().get(GENERATED_FILES_KEY);
		 generatedFiles.put(this.formatName, null);
	  }
      try {
         if (this.writer != null && this.writer.isOpen()) {
            this.writer.close();
            // Deletes the file because it may be not valid.
            if (this.file != null && this.file.delete()) {
               log.warn(i18n.getString("fileDeleted", this.file));
            } else {
               throw new IOException(i18n.getString("problemDeleting", this.file));
            }
         }
      } catch (IOException e) {
         log.error(i18n.getString("problemClosingFile"), e);
      }
      this.file = null;
   }

   /**
    * Gets the writer to the file.
    */
   public Object getInput(String sourceName) throws ConnectException,
         UnsupportedOperationException {
      return this.writer;
   }
}
